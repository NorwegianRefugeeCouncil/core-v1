package cmd

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

var fieldNames []string
var fieldTags []string
var packageName string
var fields = map[string]*ast.Field{}
var fs = token.NewFileSet()
var reflectTypes = map[string]string{}
var importPackages = map[string]struct{}{}

type Options struct {
	// The filename to generate code for
	FileName string
	// The name of the struct to generate code for
	StructName string
	// Output file
	OutputFile string
	// Logger to use
	Logger *log.Logger
	// TagName to use
	TagName      string
	TestFileName string
}

func gen(opts Options) error {

	f, err := os.Open(opts.FileName)
	if err != nil {
		return err
	}

	fileDirectory := filepath.Dir(opts.OutputFile)
	outputFileName := filepath.Base(opts.OutputFile)
	outputFileExtension := filepath.Ext(opts.OutputFile)

	testFileName := filepath.Join(fileDirectory, strings.TrimSuffix(outputFileName, outputFileExtension)+"_test"+outputFileExtension)
	opts.TestFileName = testFileName

	stat, err := f.Stat()
	if err != nil {
		return err
	}

	fs.AddFile(opts.FileName, fs.Base(), int(stat.Size()))
	file, err := parser.ParseFile(fs, opts.FileName, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	packageName = file.Name.Name
	for _, decl := range file.Decls {
		scanDeclaration(opts, decl)
	}
	return render(opts)

}

func getReflectType(field *ast.Field) (string, string, error) {
	if t, ok := field.Type.(*ast.Ident); ok {
		return t.Name, "", nil
	}
	if sel, ok := field.Type.(*ast.SelectorExpr); ok {
		ret := ""
		if t, ok := sel.X.(*ast.Ident); ok {
			ret = t.Name
		}
		return ret + "." + sel.Sel.Name, ret, nil
	}
	if star, ok := field.Type.(*ast.StarExpr); ok {
		if t, ok := star.X.(*ast.Ident); ok {
			return "*" + t.Name, "", nil
		} else if sel, ok := star.X.(*ast.SelectorExpr); ok {
			ret := ""
			if t, ok := sel.X.(*ast.Ident); ok {
				ret = t.Name
			}
			return "*" + ret + "." + sel.Sel.Name, ret, nil
		}
	}
	if array, ok := field.Type.(*ast.ArrayType); ok {
		if t, ok := array.Elt.(*ast.Ident); ok {
			return "[]" + t.Name, "", nil
		} else if sel, ok := array.Elt.(*ast.SelectorExpr); ok {
			ret := ""
			if t, ok := sel.X.(*ast.Ident); ok {
				ret = t.Name
			}
			return "[]" + ret + "." + sel.Sel.Name, ret, nil
		}
	}
	return "", "", fmt.Errorf("unknown type %s", reflect.TypeOf(field.Type))

}

var tpl = template.Must(template.New("output").Funcs(map[string]any{
	"reflectType": func(fieldName string) string {
		return reflectTypes[fieldName]
	},
	"mockValue": func(fieldName string) string {
		switch reflectTypes[fieldName] {
		case "string":
			return "\"mock\""
		case "int":
			return "1"
		case "bool":
			return "true"
		case "*bool":
			return "func () *bool { b := true; return &b }()"
		case "float64":
			return "1.0"
		case "[]string":
			return "[]string{\"mock\"}"
		case "[]int":
			return "[]int{1}"
		case "[]bool":
			return "[]bool{true}"
		case "[]float64":
			return "[]float64{1.0}"
		case "time.Time":
			return "time.Date(2018, 1, 1, 0, 0, 0, 0, time.UTC)"
		case "*time.Time":
			return "func () *time.Time { t := time.Date(2018, 1, 1, 0, 0, 0, 0, time.UTC); return &t }()"
		default:
			return "nil"
		}
	},
}).Parse(`// Code generated by gen.go. DO NOT EDIT.

{{ define "gen" }}

package {{.PackageName}}

import (
	"fmt"
	"strconv"
	"encoding/json"
{{- range $key, $value := .Imports }}
	{{ if $key }}"{{ $key }}"{{end}}
{{- end }}
)

type {{.StructName}}_Field uint8

const (
	{{- range $index, $fieldName := .FieldNames}}
	{{$.StructName}}_Field_{{$fieldName}} {{if not $index}}{{$.StructName}}_Field  = iota{{end}}
	{{- end}}
)

const _{{.StructName}}_Field_name = "{{range $index, $fieldName := .FieldTags}}{{$fieldName}}{{end}}"

var _{{.StructName}}_Field_index = [...]uint8{{"{"}}{{range $index, $offset := .Offsets}}{{if $index}},{{end}}{{$offset}}{{end}}}

func (i {{.StructName}}_Field) String() string {
	if i >= {{.StructName}}_Field(len(_{{.StructName}}_Field_index)-1) {
		return "{{.StructName}}_Field(" + strconv.FormatInt(int64(i), 10) + ")"
    }
	return _{{.StructName}}_Field_name[_{{.StructName}}_Field_index[i]:_{{.StructName}}_Field_index[i+1]]
}

func (i {{.StructName}}_Field) MarshalJSON() ([]byte, error) {
	str := i.String()
    return json.Marshal(str)
}

func (i *{{.StructName}}_Field) UnmarshalJSON(data []byte) error {
	var strVal string
    if err := json.Unmarshal(data, &strVal); err != nil {
		return err
	}
	parsed, err := Parse_{{.StructName}}_Field(strVal)
	if err != nil {
		return err
	}
	*i = parsed
	return nil
}

func (i {{.StructName}}_Field) MarshalText() ([]byte, error){
	return []byte(i.String()), nil
}

func (i *{{.StructName}}_Field) UnmarshalText(data []byte) error {
	str := string(data)
	parsed, err := Parse_{{.StructName}}_Field(str)
	if err != nil {
		return err
	}
	*i = parsed
	return nil
}

func All_{{.StructName}}_Fields() []{{.StructName}}_Field {
  return []{{.StructName}}_Field{
	{{- range $index, $fieldName := .FieldNames}}
	{{$.StructName}}_Field_{{$fieldName}},
	{{- end}}
  }
}

func Parse_{{.StructName}}_Field(value string) ({{.StructName}}_Field, error){
	switch value {
	{{- range $index, $fieldName := .FieldTags}}
	case "{{$fieldName}}":
		return {{$.StructName}}_Field_{{index $.FieldNames $index}}, nil
	{{- end}}
	default:
		return 0, fmt.Errorf("unknown {{.StructName}} field %s", value)
	}
}

func Get_{{.StructName}}_FieldValue(i *{{.StructName}}, field {{.StructName}}_Field) (interface{}, error) {
	switch field {
	{{- range $index, $fieldName := .FieldNames}}
	case {{$.StructName}}_Field_{{$fieldName}}:	
		return i.{{$fieldName}}, nil
	{{- end}}
	default:
		return nil, fmt.Errorf("unknown field %s", field)
	}
}

func Set_{{.StructName}}_FieldValue(i *{{.StructName}}, field {{.StructName}}_Field, value interface{}) error {
	switch field {
	{{- range $index, $fieldName := .FieldNames}}
	case {{$.StructName}}_Field_{{$fieldName}}:
		if v, ok := value.({{reflectType .}}); ok {
			i.{{$fieldName}} = v
			return nil
		}
		return fmt.Errorf("invalid value type for field %s. Expected %T but got %T", field, i.{{$fieldName}}, value)
	{{- end}}
	default:
		return fmt.Errorf("unknown field %s", field)
	}
}

type {{.StructName}}_Builder struct {
	{{- range $index, $fieldName := .FieldNames}}
	{{ $fieldName }} {{reflectType .}}
	{{- end}}
}

func New_{{.StructName}}_Builder() *{{.StructName}}_Builder {
	return &{{.StructName}}_Builder{}
}

{{- range $index, $fieldName := .FieldNames}}
func (b *{{$.StructName}}_Builder) With{{$fieldName}}(value {{reflectType .}}) *{{$.StructName}}_Builder {
	b.{{$fieldName}} = value
	return b
}
{{- end}}

func (b *{{.StructName}}_Builder) Build() *{{.StructName}} {
	ret := &{{.StructName}}{
		{{- range $index, $fieldName := .FieldNames}}
		{{$fieldName}}: b.{{$fieldName}},
		{{- end}}
	}
	return ret
}

{{end}}

{{define "tests" }}
package {{.PackageName}}


import (
	"testing"
	"github.com/stretchr/testify/assert"
	"encoding/json"
{{- range $key, $value := .Imports }}
	{{ if $key }}"{{ $key }}"{{end}}
{{- end }}
)

func Test_{{.StructName}}_Field_String(t *testing.T) {
	tests := []struct {
		name string
		field {{.StructName}}_Field
		expected string
	}{
		{{- range $index, $fieldName := .FieldNames}}
		{name: "{{index $.FieldTags $index}}", field: {{$.StructName}}_Field_{{$fieldName}}, expected: "{{index $.FieldTags $index}}"},
		{{- end}}	
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			assert.Equal(t, test.expected, test.field.String())
		})
	}
}

func Test_{{.StructName}}_Field_MarshalJSON(t *testing.T) {
	type dummy struct { Field {{.StructName}}_Field }
	tests := []struct {
		name string
		field {{.StructName}}_Field
		expected string
	}{
		{{- range $index, $fieldName := .FieldNames}}
		{name: "{{index $.FieldTags $index}}", field: {{$.StructName}}_Field_{{$fieldName}}, expected: "{{"{"}}\"Field\":\"{{index $.FieldTags $index}}\"{{"}"}}"},
		{{- end}}
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			d := dummy{Field: test.field}
			bytes, err := json.Marshal(d)
			assert.NoError(t, err)
			assert.Equal(t, test.expected, string(bytes))
		})
	}
}

func Test_{{.StructName}}_Field_UnmarshalJSON(t *testing.T){
	type dummy struct { Field {{.StructName}}_Field }
	tests := []struct {
		name string
		json string
		expected dummy
	}{
		{{- range $index, $fieldName := .FieldNames}}
		{name: "{{index $.FieldTags $index}}", json: "{{"{"}}\"Field\":\"{{index $.FieldTags $index}}\"{{"}"}}", expected: dummy{Field: {{$.StructName}}_Field_{{$fieldName}}}},
		{{- end}}
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			var d dummy
			err := json.Unmarshal([]byte(test.json), &d)
			assert.NoError(t, err)
			assert.Equal(t, test.expected, d)
		})
	}
}


func Test_{{.StructName}}_Field_MarshalText(t *testing.T) {
	tests := []struct {
		name string
		field {{.StructName}}_Field
		expected string
	}{
		{{- range $index, $fieldName := .FieldNames}}
		{name: "{{index $.FieldTags $index}}", field: {{$.StructName}}_Field_{{$fieldName}}, expected: "{{index $.FieldTags $index}}"},
		{{- end}}
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			bytes, err := test.field.MarshalText()
			assert.NoError(t, err)
			assert.Equal(t, test.expected, string(bytes))
		})
	}
}

func Test_{{.StructName}}_Field_UnmarshalText(t *testing.T){
	tests := []struct {
		name string
		text string
		expected {{.StructName}}_Field
	}{
		{{- range $index, $fieldName := .FieldNames}}
		{name: "{{index $.FieldTags $index}}", text: "{{index $.FieldTags $index}}", expected: {{$.StructName}}_Field_{{$fieldName}}},
		{{- end}}
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			var field = new({{.StructName}}_Field)
			err := field.UnmarshalText([]byte(test.text))
			assert.NoError(t, err)
			assert.Equal(t, test.expected, *field)
		})
	}
}
			
func Test_{{.StructName}}_All{{.StructName}}(t *testing.T) {
	assert.ElementsMatch(t, []{{.StructName}}_Field{
		{{- range $index, $fieldName := .FieldNames}}
		{{$.StructName}}_Field_{{$fieldName}},
		{{- end}}
	}, All_{{.StructName}}_Fields())
}

func Test_Parse_{{.StructName}}_Field(t *testing.T){
	tests := []struct {
		name string
		text string
		expected {{.StructName}}_Field
	}{
		{{- range $index, $fieldName := .FieldNames}}
		{name: "{{index $.FieldTags $index}}", text: "{{index $.FieldTags $index}}", expected: {{$.StructName}}_Field_{{$fieldName}}},
		{{- end}}
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			parsed, err := Parse_{{.StructName}}_Field(test.text)
			assert.NoError(t, err)
			assert.Equal(t, test.expected, parsed)
		})
	}
}

func Test_Get_{{.StructName}}_Field_Value(t *testing.T) {
	tests := []struct {
		name string
		field {{.StructName}}_Field
		object *{{.StructName}}
		expected interface{}
	}{
		{{- range $index, $fieldName := .FieldNames}}
		{"{{index $.FieldTags $index}}", {{$.StructName}}_Field_{{$fieldName}}, &{{$.StructName}}{{"{"}}{{$fieldName}}: {{mockValue $fieldName}}{{"}"}}, {{mockValue $fieldName}},},
		{{- end}}
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			val, err := Get_{{.StructName}}_FieldValue(test.object, test.field)
			assert.NoError(t, err)
			assert.Equal(t, test.expected, val)
		})
	}
}

func Test_Set_{{.StructName}}_Field_Value(t *testing.T) {
	tests := []struct {
		name string
		field {{.StructName}}_Field
		value interface{}
		expected *{{.StructName}}
	}{
		{{- range $index, $fieldName := .FieldNames}}
		{"{{index $.FieldTags $index}}", {{$.StructName}}_Field_{{$fieldName}}, {{mockValue $fieldName}}, &{{$.StructName}}{{"{"}}{{$fieldName}}: {{mockValue $fieldName}}{{"}"}},},
		{{- end}}
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			object := &{{$.StructName}}{{"{"}}{{"}"}}
			err := Set_{{.StructName}}_FieldValue(object, test.field, test.value)
			assert.NoError(t, err)
			assert.Equal(t, test.expected, object)
		})
	}
}

func Test_{{.StructName}}_Builder(t *testing.T){
	tests := []struct {
		name string
		builderFunc func(builder *{{.StructName}}_Builder)
		expect *{{.StructName}}
	}{
		{{- range $index, $fieldName := .FieldNames}}
		{"{{index $.FieldTags $index}}", func(builder *{{$.StructName}}_Builder) { builder.With{{$fieldName}}({{mockValue $fieldName}}) }, &{{$.StructName}}{{"{"}}{{$fieldName}}: {{mockValue $fieldName}}{{"}"}},},
		{{- end}}
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			b := New_{{.StructName}}_Builder()
			test.builderFunc(b)
			assert.Equal(t, test.expect, b.Build())
		})
	}
}

{{end}}

`))

func render(opts Options) error {
	opts.Logger.Printf("Rendering %s", opts.OutputFile)
	offsets := make([]int, len(fieldTags)+1)
	for i := 1; i < len(offsets); i++ {
		offsets[i] = offsets[i-1] + len(fieldTags[i-1])
	}
	data := map[string]interface{}{
		"PackageName": packageName,
		"StructName":  opts.StructName,
		"FieldNames":  fieldNames,
		"FieldTags":   fieldTags,
		"Offsets":     offsets,
		"Imports":     importPackages,
	}
	outFile, err := openFile(opts.OutputFile)
	if err != nil {
		return err
	}
	defer outFile.Close()

	testFile, err := openFile(opts.TestFileName)
	if err != nil {
		return err
	}
	defer testFile.Close()

	if err := tpl.ExecuteTemplate(outFile, "gen", data); err != nil {
		return err
	}
	if err := tpl.ExecuteTemplate(testFile, "tests", data); err != nil {
		return err
	}
	return nil
}

func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	return err == nil
}

func deleteFileIfExists(filename string) error {
	if fileExists(filename) {
		fmt.Println("Deleting file ", filename)
		return os.Remove(filename)
	}
	return nil
}

func openFile(filename string) (*os.File, error) {
	fmt.Println("Opening file ", filename)
	if err := deleteFileIfExists(filename); err != nil {
		return nil, err
	}
	return os.OpenFile(filename, os.O_CREATE|os.O_WRONLY, 0644)
}

func scanDeclaration(opts Options, decl ast.Decl) {
	if genDecl, ok := decl.(*ast.GenDecl); ok {
		scanGenDecl(opts, genDecl)
	}
}
func scanGenDecl(opts Options, genDecl *ast.GenDecl) {
	if genDecl.Tok == token.TYPE {
		for _, spec := range genDecl.Specs {
			scanSpec(opts, spec)
		}
	}
}

func scanSpec(opts Options, spec ast.Spec) {
	if typeSpec, ok := spec.(*ast.TypeSpec); ok {
		scanTypeSpec(opts, typeSpec)
	}
}

func scanTypeSpec(opts Options, typeSpec *ast.TypeSpec) {
	if typeSpec.Name.Name != opts.StructName {
		return
	}
	if structType, ok := typeSpec.Type.(*ast.StructType); ok {
		scanStructType(opts, structType)
	}
}

func scanStructType(opts Options, structType *ast.StructType) {
	for _, field := range structType.Fields.List {
		scanField(opts, field)
	}
}

func scanField(opts Options, field *ast.Field) {
	if len(field.Names) == 0 {
		return
	}
	fieldName := field.Names[0].Name
	fieldTag := getTagForField(opts, field)
	opts.Logger.Printf("Found field \"%s\"", fieldName)
	fieldNames = append(fieldNames, fieldName)
	fieldTags = append(fieldTags, fieldTag)
	reflectType, pkg, err := getReflectType(field)
	if err != nil {
		opts.Logger.Fatal(err)
	}
	importPackages[pkg] = struct{}{}
	reflectTypes[fieldName] = reflectType
	fields[fieldName] = field
}

func getTagForField(opts Options, field *ast.Field) string {
	ret := field.Names[0].Name
	if field.Tag == nil {
		return ret
	}
	tag := field.Tag.Value
	if len(tag) < 2 {
		return ret
	}
	if tagValue, ok := reflect.StructTag(tag[1 : len(tag)-1]).Lookup(opts.TagName); ok {
		parts := strings.Split(tagValue, ",")
		if len(parts) > 0 {
			ret = parts[0]
		}
	}
	return ret
}
