package cmd

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"reflect"
	"strings"
	"text/template"
)

var fieldNames []string
var fieldTags []string
var packageName string
var fields = map[string]*ast.Field{}
var fs = token.NewFileSet()
var reflectTypes = map[string]string{}
var importPackages = map[string]struct{}{}

type Options struct {
	// The filename to generate code for
	FileName string
	// The name of the struct to generate code for
	StructName string
	// Output file
	OutputFile string
	// Logger to use
	Logger *log.Logger
	// TagName to use
	TagName string
}

func gen(opts Options) error {
	importPackages["fmt"] = struct{}{}
	importPackages["strconv"] = struct{}{}

	f, err := os.Open(opts.FileName)
	if err != nil {
		return err
	}
	stat, err := f.Stat()
	if err != nil {
		return err
	}

	fs.AddFile(opts.FileName, fs.Base(), int(stat.Size()))
	file, err := parser.ParseFile(fs, opts.FileName, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	packageName = file.Name.Name
	for _, decl := range file.Decls {
		scanDeclaration(opts, decl)
	}
	return render(opts)

}

var file *ast.File

func getReflectType(field *ast.Field) (string, string, error) {
	if t, ok := field.Type.(*ast.Ident); ok {
		return t.Name, "", nil
	}
	if sel, ok := field.Type.(*ast.SelectorExpr); ok {
		ret := ""
		if t, ok := sel.X.(*ast.Ident); ok {
			ret = t.Name
		}
		return ret + "." + sel.Sel.Name, ret, nil
	}
	if star, ok := field.Type.(*ast.StarExpr); ok {
		if t, ok := star.X.(*ast.Ident); ok {
			return "*" + t.Name, "", nil
		} else if sel, ok := star.X.(*ast.SelectorExpr); ok {
			ret := ""
			if t, ok := sel.X.(*ast.Ident); ok {
				ret = t.Name
			}
			return "*" + ret + "." + sel.Sel.Name, ret, nil
		}
	}
	if array, ok := field.Type.(*ast.ArrayType); ok {
		if t, ok := array.Elt.(*ast.Ident); ok {
			return "[]" + t.Name, "", nil
		} else if sel, ok := array.Elt.(*ast.SelectorExpr); ok {
			ret := ""
			if t, ok := sel.X.(*ast.Ident); ok {
				ret = t.Name
			}
			return "[]" + ret + "." + sel.Sel.Name, ret, nil
		}
	}
	return "", "", fmt.Errorf("unknown type %s", reflect.TypeOf(field.Type))

}

var tpl = template.Must(template.New("output").Funcs(map[string]any{
	"reflectType": func(fieldName string) string {
		return reflectTypes[fieldName]
	},
}).Parse(`// Code generated by gen.go. DO NOT EDIT.

package {{.PackageName}}

import (
{{- range $key, $value := .Imports }}
	{{ if $key }}"{{ $key }}"{{end}}
{{- end }}
)

type {{.StructName}}_Field uint8

const (
	{{- range $index, $fieldName := .FieldNames}}
	{{$.StructName}}_Field_{{$fieldName}} {{if not $index}}{{$.StructName}}_Field  = iota{{end}}
	{{- end}}
)

const _{{.StructName}}_Field_name = "{{range $index, $fieldName := .FieldTags}}{{$fieldName}}{{end}}"

var _{{.StructName}}_Field_index = [...]uint8{{"{"}}{{range $index, $offset := .Offsets}}{{if $index}},{{end}}{{$offset}}{{end}}}

func (i {{.StructName}}_Field) String() string {
	if i >= {{.StructName}}_Field(len(_{{.StructName}}_Field_index)-1) {
		return "{{.StructName}}_Field(" + strconv.FormatInt(int64(i), 10) + ")"
    }
	return _{{.StructName}}_Field_name[_{{.StructName}}_Field_index[i]:_{{.StructName}}_Field_index[i+1]]
}

func All_{{.StructName}}_Fields() []{{.StructName}}_Field {
  return []{{.StructName}}_Field{
	{{- range $index, $fieldName := .FieldNames}}
	{{$.StructName}}_Field_{{$fieldName}},
	{{- end}}
  }
}

func Parse_{{.StructName}}_Field(value string) ({{.StructName}}_Field, error){
	switch value {
	{{- range $index, $fieldName := .FieldTags}}
	case "{{$fieldName}}":
		return {{$.StructName}}_Field_{{index $.FieldNames $index}}, nil
	{{- end}}
	default:
		return 0, fmt.Errorf("unknown {{.StructName}} field %s", value)
	}
}

func Get_{{.StructName}}_FieldValue(i *{{.StructName}}, field {{.StructName}}_Field) (interface{}, error) {
	switch field {
	{{- range $index, $fieldName := .FieldNames}}
	case {{$.StructName}}_Field_{{$fieldName}}:	
		return i.{{$fieldName}}, nil
	{{- end}}
	default:
		return nil, fmt.Errorf("unknown field %s", field)
	}
}

func Set_{{.StructName}}_FieldValue(i *{{.StructName}}, field {{.StructName}}_Field, value interface{}) error {
	switch field {
	{{- range $index, $fieldName := .FieldNames}}
	case {{$.StructName}}_Field_{{$fieldName}}:
		if v, ok := value.({{reflectType .}}); ok {
			i.{{$fieldName}} = v
			return nil
		}
		return fmt.Errorf("invalid value type for field %s. Expected %T but got %T", field, i.{{$fieldName}}, value)
	{{- end}}
	default:
		return fmt.Errorf("unknown field %s", field)
	}
}

type {{.StructName}}_Builder struct {
	{{- range $index, $fieldName := .FieldNames}}
	{{ $fieldName }} {{reflectType .}}
	{{- end}}
}

func New_{{.StructName}}_Builder() *{{.StructName}}_Builder {
	return &{{.StructName}}_Builder{}
}

{{- range $index, $fieldName := .FieldNames}}
func (b *{{$.StructName}}_Builder) With{{$fieldName}}(value {{reflectType .}}) *{{$.StructName}}_Builder {
	b.{{$fieldName}} = value
	return b
}
{{- end}}

func (b *{{.StructName}}_Builder) Build() *{{.StructName}} {
	ret := &{{.StructName}}{
		{{- range $index, $fieldName := .FieldNames}}
		{{$fieldName}}: b.{{$fieldName}},
		{{- end}}
	}
	return ret
}

`))

func render(opts Options) error {
	opts.Logger.Printf("Rendering %s", opts.OutputFile)
	offsets := make([]int, len(fieldTags)+1)
	for i := 1; i < len(offsets); i++ {
		offsets[i] = offsets[i-1] + len(fieldTags[i-1])
	}
	data := map[string]interface{}{
		"PackageName": packageName,
		"StructName":  opts.StructName,
		"FieldNames":  fieldNames,
		"FieldTags":   fieldTags,
		"Offsets":     offsets,
		"Imports":     importPackages,
	}
	outFile, err := openFile(opts.OutputFile)
	if err != nil {
		return err
	}
	defer outFile.Close()

	if err := tpl.Execute(outFile, data); err != nil {
		return err
	}
	return nil
}

func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	return err == nil
}

func deleteFileIfExists(filename string) error {
	if fileExists(filename) {
		fmt.Println("Deleting file ", filename)
		return os.Remove(filename)
	}
	return nil
}

func openFile(filename string) (*os.File, error) {
	fmt.Println("Opening file ", filename)
	if err := deleteFileIfExists(filename); err != nil {
		return nil, err
	}
	return os.OpenFile(filename, os.O_CREATE|os.O_WRONLY, 0644)
}

func scanDeclaration(opts Options, decl ast.Decl) {
	if genDecl, ok := decl.(*ast.GenDecl); ok {
		scanGenDecl(opts, genDecl)
	}
}
func scanGenDecl(opts Options, genDecl *ast.GenDecl) {
	if genDecl.Tok == token.TYPE {
		for _, spec := range genDecl.Specs {
			scanSpec(opts, spec)
		}
	}
}

func scanSpec(opts Options, spec ast.Spec) {
	if typeSpec, ok := spec.(*ast.TypeSpec); ok {
		scanTypeSpec(opts, typeSpec)
	}
}

func scanTypeSpec(opts Options, typeSpec *ast.TypeSpec) {
	if typeSpec.Name.Name != opts.StructName {
		return
	}
	if structType, ok := typeSpec.Type.(*ast.StructType); ok {
		scanStructType(opts, structType)
	}
}

func scanStructType(opts Options, structType *ast.StructType) {
	for _, field := range structType.Fields.List {
		scanField(opts, field)
	}
}

func scanField(opts Options, field *ast.Field) {
	if len(field.Names) == 0 {
		return
	}
	fieldName := field.Names[0].Name
	fieldTag := getTagForField(opts, field)
	opts.Logger.Printf("Found field \"%s\"", fieldName)
	fieldNames = append(fieldNames, fieldName)
	fieldTags = append(fieldTags, fieldTag)
	reflectType, pkg, err := getReflectType(field)
	if err != nil {
		opts.Logger.Fatal(err)
	}
	importPackages[pkg] = struct{}{}
	reflectTypes[fieldName] = reflectType
	fields[fieldName] = field
}

func getTagForField(opts Options, field *ast.Field) string {
	ret := field.Names[0].Name
	if field.Tag == nil {
		return ret
	}
	tag := field.Tag.Value
	if len(tag) < 2 {
		return ret
	}
	if tagValue, ok := reflect.StructTag(tag[1 : len(tag)-1]).Lookup(opts.TagName); ok {
		parts := strings.Split(tagValue, ",")
		if len(parts) > 0 {
			ret = parts[0]
		}
	}
	return ret
}
